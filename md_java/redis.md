# 一、 Redis 各种数据结构使用的场景

## 1. Redis有5种数据类型
String - 字符串
Hash - 字典
List - 列表
Set - 集合
Sorted Set - 有序集合

## 2. 下面是不同类型的使用场合

### 1. String - 字符串
    
String数据类型是简单的key-value类型,value不仅可以是String，也可以是数字(当数字类型是Long，可以表示的时候encoding就是整型，其他都储存在sdshdr当作字符串)。使用String类型，可以完全实现目前的Memcached的功能，并且效率更高，还可以享受Redis的定时持久化(可以选择RDB模式或者AOF模式)，操作日志以及Replication等功能，除了提供与Memcached一样的get、set、incr、decr等操作外，Redis还提供了下面一些操作：
    
> 1. LEN ns: O(1)获取字符串长度
> 2. APPEND ns redis:  往字符串append内容，而且采用智能分配的内存（每次两倍）
> 3. 设置和获取字符串的某一段内容
> 4. 设置以及获取字符串的某一位（bit）
> 5. 批量设置一系列字符串的内容
> 6. 原子计数器
> 7. GETSET 命令的妙用，请与清空旧值得同时设置一个新值，配合原子计数器使用
    
### 2. Hash - 字典

在Memcached中，我们经常将一些结构化得信息打包成hashmap，在客户端序列化后储存为一个字符串的值（一般是JSON格式），比如用户信息，这时候需要修改其中某一项时，通常需要将字符串（JSON）取出来，然后进行反序列化操作，修改某一项的值，然后再序列化储存回去，简单修改一个属性就需要干这么多事情，消耗必定是很大的，也不适用于一些可能并发操作的场合（比如两个并发的操作都需要修改积分）。而Redis的Hash结构可以使你像在数据库Update一个属性一样只修改某一项属性。

> 储存、读取、修改用户数据

### 3. List - 列表

List 说白了就是链表（Redis使用双端链表实现的List），学过数据结构的都应该理解这种结构，使用List结构，我们可以轻松实现最新消息排行等功能（比如新浪博客的TimeLine),List的另一个应用就是消息队列，可以利用List的*Push操作，将任务存在List中，然后工作线程再POP操作将任务取出来进行执行，Redis还提供了操作List中某一段元素的API，你可以直接查询、删除List中某一段元素。

> 1. 微博TimeLine
> 2. 消息队列

### 4. Set - 集合

Set 就是一个集合，集合的概念就是一堆不重复的组合。利用Redis提供的Set数据结构，可以储存一些集合性的数据。比如在微博应用中，可以将一个用户所有关注人存在一个集合中，将其所有粉丝存在一个集合，因为Redis非常人性化的为集合提供了求交集、并集、差集等操作，那么就可以非常方便的实现如共同关注、共同喜好、二度好友等功能，对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存集到一个新的集合

> 1. 共同好友、二度好友
> 2. 利用唯一性，可以统计访问网站的所有独立IP
> 3. 好友推荐的时候，根据tag求交集，大于某个threshold就可以推荐

### 5. Sorted Set - 有序集合

和Set相比，Sorted Set 是将Set中的元素增加一个权重参数，使得集合中的元素能够按照score进行排序，比如一个储存全班同学成绩的Sorted Set，其集合value可以是同学的学号，而score就可以是其考试得分，这样在数据插入集合的时候，就已经进行了天然的排序。另外还可以用Sorted Set来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程就可以选择按score的倒序来获取工作任务，让重要的任务优先执行。

> 1. 带有权重的元素，比如一个游戏的用户得分排行榜
> 2. 比较复杂的数据结构，一般用到的场合不算多

# 二、 Redis其他使用场景

## 1. 订阅 - 发布系统

Pub/Sub 从字面上理解就是发布（Publish）与订阅（Subscribe），在Redis中，你可以设定某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息，这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。

## 2. 事务 - Transactions

谁说NoSQL都不支持事务，虽然Redis的Transactions提供的并不是严格的ACID的食物（比如一串用EXEC提交执行的命令，在执行中服务器宕机，那么会有那么一部分指令没执行到），但是这个Transactions还是提供了基本的命令打包执行的功能（在服务器不出问题的情况下，可以保证一连串的命令是按顺序一起执行的，中间不会有其他客户端插进来），Redis还提供了一个Watch功能，你可以对一个key进行watch然后再执行Transactions，在这个过程中，如果这个watched的值进行了修改，那么这个Transactions会发现并拒绝执行。
